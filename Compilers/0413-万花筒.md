## Kaleidoscope: Lexer

https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.html

### The Lexer

在实现一种语言时，首先需要的是能够处理文本文件并识别它所说的内容。 这样做的传统方法是使用“词法分析器”（又名“扫描器”）将输入分解为“token”。 词法分析器返回的每个标记都包含一个标记代码和一些可能的元数据（例如，数字的数值）。 首先，我们定义可能性：

```c++
// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
// of these for known things.
enum Token {
  tok_eof = -1, 

  // commands
  tok_def = -2, 
  tok_extern = -3, 

  // primary
  tok_identifier = -4, 
  tok_number = -5
};

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number
```

我们的词法分析器返回的每个标记要么是 Token 枚举值之一，要么是一个“未知”字符，如“+”，作为其 ASCII 值返回。 如果当前标记是标识符，则 IdentifierStr 全局变量保存标识符的名称。 如果当前标记是数字文字（如 1.0），则 NumVal 保留其值。 为简单起见，我们使用全局变量，但这不是真正语言实现的最佳选择:)。



词法分析器的实际实现是一个名为 gettok 的函数。 调用 gettok 函数以从标准输入返回下一个标记。 它的定义开始于：

```c++
/// gettok - Return the next token from standard input.
static int gettok() {
  static int LastChar = ' ';

  // Skip any whitespace.
  while (isspace(LastChar))
    LastChar = getchar();

 /*
 gettok 通过调用 C getchar() 函数从标准输入一次读取一个字符来工作。 它在识别它们时吃掉它们，并将最后读取但未处理的字符存储在 LastChar 中。 它必须做的第一件事是忽略标记之间的空白。 这是通过上面的循环完成的。

gettok 需要做的下一件事是识别标识符和特定关键字，如“def”。 Kaleidoscope 使用这个简单的循环来做到这一点：
 */
  if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*
    IdentifierStr = LastChar;
    while (isalnum((LastChar = getchar())))
      IdentifierStr += LastChar;

    if (IdentifierStr == "def")
      return tok_def;
    if (IdentifierStr == "extern")
      return tok_extern;
    return tok_identifier;
  }

    /*
    请注意，此代码会在对标识符进行词法分析时将“IdentifierStr”设置为全局。 此外，由于语言关键字由同一循环匹配，因此我们在这里以内联方式处理它们。 数值相似：
    
    这些都是用于处理输入的非常简单的代码。 从输入中读取数值时，我们使用 C strtod 函数将其转换为存储在 NumVal 中的数值。 请注意，这并没有进行足够的错误检查：它会错误地读取“1.23.45.67”并像您输入“1.23”一样处理它。 随意扩展它！ 接下来我们处理评论：
    */
  if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+
    std::string NumStr;
    do {
      NumStr += LastChar;
      LastChar = getchar();
    } while (isdigit(LastChar) || LastChar == '.');

    NumVal = strtod(NumStr.c_str(), nullptr);
    return tok_number;
  }
/*
我们通过跳到行尾来处理评论，然后返回下一个标记。 最后，如果输入与上述情况之一不匹配，则它要么是像“+”这样的运算符字符，要么是文件末尾。 这些是用这段代码处理的：
*/
  if (LastChar == '#') {
    // Comment until end of line.
    do  
      LastChar = getchar();
    while (LastChar != EOF && LastChar != '\n' && LastChar != '\r');

    if (LastChar != EOF)
      return gettok();
  }

  // Check for end of file.  Don't eat the EOF.
  if (LastChar == EOF)
    return tok_eof;

  // Otherwise, just return the character as its ascii value.
  int ThisChar = LastChar;
  LastChar = getchar();
  return ThisChar;
}
```

### Kaleidoscope:Implementing a Parser and AST

欢迎阅读“使用 LLVM 实现语言”教程的第 2 章。 本章向您展示如何使用第 1 章中构建的词法分析器为我们的 Kaleidoscope 语言构建一个完整的解析器。 有了解析器后，我们将定义并构建一个抽象语法树 (AST)。

我们将构建的解析器结合使用**递归下降解析和运算符优先解析**来解析 Kaleidoscope 语言（后者用于二进制表达式，前者用于其他所有内容）。 在我们开始解析之前，让我们先谈谈解析器的输出：抽象语法树。



#### AST

程序的 AST 以一种易于编译器后期阶段（例如代码生成）解释的方式捕获其行为。 我们基本上希望语言中的每个结构都有一个对象，而 AST 应该紧密地模拟语言。 在 Kaleidoscope 中，我们有表达式、原型和函数对象。 我们首先从表达式开始：



```c++
/// ExprAST - Base class for all expression nodes.
class ExprAST {
public:
  virtual ~ExprAST() = default;
};

/// NumberExprAST - Expression class for numeric literals like "1.0".
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}
};

/// VariableExprAST - Expression class for referencing a variable, like "a".
class VariableExprAST : public ExprAST {
  std::string Name;

public:
  VariableExprAST(const std::string &Name) : Name(Name) {}
};

/// BinaryExprAST - Expression class for a binary operator.
class BinaryExprAST : public ExprAST {
  char Op;
  std::unique_ptr<ExprAST> LHS, RHS;

public:
  BinaryExprAST(char Op, std::unique_ptr<ExprAST> LHS,
                std::unique_ptr<ExprAST> RHS)
      : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}
};
```

