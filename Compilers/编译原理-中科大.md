## 4.3.2 二义性文法

给定文法G，如果存在句子s，它有两棵不同的分析树，那么称G是二义性文法。

从编译器角度， 二义性文法存在问题。

- 同一个程序会有不同的含义
- 程序运行的结果不是唯一的。

解决方法： 文法的重写

`表达式文法的重写`

![image-20230626204932294](images/image-20230626204932294.png)

  ![image-20230626212350722](images/image-20230626212350722.png)

## 语法分析

### 自顶向下分析

语法分析：给定文法G和句子s， 回答s是否能够从G推导出来？

基本算法思想：从G的开始符号出发，随意推导出某个句子t， 比较t和s

- 若t == s， 则回答是
- 若t！=s，则？

因为这是从开始符号出发推导出句子，因此称为自顶向下分析。

对应分析树自顶向下的构造顺序。	

```txt
tokens[];		// all tokens
i = 0;
stack = [S]		// S是开始符号
while(stack != [])
	if(stack[top] is a terminal t)
		if(t == token[i++])
			pop();
		else backtrack();
	else if (stack[top] is a nonterminal T)
		pop();
		push(the next right hand side of T)
```

https://www.bilibili.com/video/BV16h411X7JY?t=125.1&p=41

### 递归下降分析算法

![image-20230628212814128](images/image-20230628212814128.png)

- 算法基本思想
  - 每个非终结符构造一个分析函数。
  - 用*前看符号* 指导产生式规则的选择。

示例：

![image-20230628214134542](images/image-20230628214134542.png)

一般的算法框架

```
Parse_X()
	token = nextToken()
	switch(token)
	case ...: 
```

![image-20230629085440038](images/image-20230629085440038.png)

![image-20230629085405724](images/image-20230629085405724.png)

### LL(1)分析算法

语法分析器自动生成，利用分析工具。

![image-20230629092003567](images/image-20230629092003567.png)

LL(1) 分析算法

- 从左（L）向右读入程序，最左L推导，采用一个1 前向符号。
  - 分析高效 线性时间
  - 错误定位和诊断信息准确
  - 很多开源或者商业的生成工具
    - ANTLR

- 算法基本思想
  - 表驱动的分析算法

表驱动的LL分析器架构

![image-20230629093224663](images/image-20230629093224663.png)







