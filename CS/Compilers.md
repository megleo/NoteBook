# 编译原理（中科大）

## 课程简介

1. 什么是编译器？
   - 成百种语言最终需要转换成机器能识别的二进制机器码

## 词法分析的手工构造1

1. 词法分析器的任务

   ![image-20230331200315557](images/image-20230331200315557.png)

### 词法分析器的实现方式

- 手工编码实现法
  - 相对复杂、且容易出错
  - 但是目前非常流行的实现方法 LLVM、GCC
- 词法分析器的生成器
  - 可快速原型，代码量少
  - 但是难以控制细节



### 转移图

![image-20230331201550265](images/image-20230331201550265.png)

- 代码实现

  ​		

![image-20230331201733605](images/image-20230331201733605.png)





### 标识符和关键字

- 在很多语言中的标识符和关键字有交集
  - 从词法分析的角度看，关键字是标识符的一部分。
- 以C语言为例子
  - 标识符：以字符或者下划线开头，后跟零个或多个字母、下划线、或数字
  - 关键字： if, while, else,....



### 识别关键字的算法

1. 转移图法

![image-20230331203100212](images/image-20230331203100212.png)



2. 关键字表算法
   - 对给定语言中所有的关键字，构造关键字构成的哈希表H。
   - 对所有的标识符和关键字，先统一按标识符的转移图进行识别。
   - 识别完成以后，进一步查表H看是否是关键字。
   - 通过合理的构造哈希表H(完美哈希)，可在O(1)时间完成。



---

## 词法分析生成器---正则表达式

### 如何写声明式的规范

#### 正则表达式

  ![image-20230401154227287](images/image-20230401154227287.png)



#### 正则表达式的形式表示

![image-20230401155046846](images/image-20230401155046846.png)



#### 例子： 关键字

$$
\sum = {ASCII}
$$

C语言中的字符集是256个ASCII值。

- C语言中的关键字，例如if, while等

  - 如何利用正则表达式表示

    if 可以是一个正则表达式i和一个正则表达式f的连接。

- C语言中的标识符：以字母或下划线开头，后跟零个或者多个字母、数字或下划线。

  - 如何用正则表达式表示

    ![image-20230401160521023](images/image-20230401160521023.png)



### 语法糖

- 可以引入更多的语法糖， 来简化构造

   ![image-20230401161115374](images/image-20230401161115374.png)

---

## 词法分析--- 有限状态自动机FA

![image-20230401161315154](images/image-20230401161315154.png)



![image-20230401185030049](images/image-20230401185030049.png)



 ![image-20230401185836203](images/image-20230401185836203.png)



### 非确定的有限状态机 NFA

![image-20230401190515210](images/image-20230401190515210.png)







![image-20230401201956214](images/image-20230401201956214.png)



![image-20230401202327392](images/image-20230401202327392.png)



---

## 词法分析 --- 正则表达式到非确定有限状态自动机



![image-20230401203104904](images/image-20230401203104904.png) 



### RE -> NFA Thompson算法

- 基于对RE的结构做归纳
  - 对基本的RE直接构造
  - 对复杂的RE递归构造
- 递归算法，容易实现
  - 在我们的代码实现里面，不到100行的C代码



![image-20230401204241097](images/image-20230401204241097.png)





![image-20230401204607489](images/image-20230401204607489.png)






$$
a(b|c)*\\

// 优先级： （）> * > 连接>选择 
$$
![image-20230401205556892](images/image-20230401205556892.png)

---



## NFA转换成DFA 子集构造算法

#### 算法思想

 ![image-20230402124320559](images/image-20230402124320559.png)



#### 子集构造算法

![image-20230402124903868](images/image-20230402124903868.png)




$$
q0  <- eps_closure(n0)
$$
计算起始位置的闭包q0



![image-20230402132033889](images/image-20230402132033889.png)



### 对算法的讨论

- 不动点算法

  - 算法为什么能够运行终止？

    因为不是每个子集都能够再次加入Q

![image-20230402132529079](images/image-20230402132529079.png)



#### 深度优先 毕包计算

![image-20230402133413198](images/image-20230402133413198.png)



![image-20230402133647101](images/image-20230402133647101.png)







## 词法分析 DFA的最小化

![image-20230402134114161](images/image-20230402134114161.png)





![image-20230402134556981](images/image-20230402134556981.png)



### Hopcroft算法

![image-20230402140455581](images/image-20230402140455581.png)



![image-20230402140902462](images/image-20230402140902462.png)



---

## 词法分析---DFA的代码表示

![image-20230402144647160](images/image-20230402144647160.png)



![image-20230402145546863](images/image-20230402145546863.png)



![image-20230402150353362](images/image-20230402150353362.png)



![image-20230402152137658](images/image-20230402152137658.png)



## 语法分析--- 简介

### 语法分析器的任务



![image-20230402152713533](images/image-20230402152713533.png)





![image-20230402153035158](images/image-20230402153035158.png)



 

![image-20230402153354348](images/image-20230402153354348.png)





![image-20230402153458239](images/image-20230402153458239.png)



---



![image-20230402154504866](images/image-20230402154504866.png)



### 上下文无关文法

![image-20230402161350836](images/image-20230402161350836.png)



##### 示例

![image-20230402161841610](images/image-20230402161841610.png)



![image-20230402162839362](images/image-20230402162839362.png)



#### 推导

![image-20230402163231253](images/image-20230402163231253.png)

#### 最左推导和最右推导



![image-20230402163536096](images/image-20230402163536096.png)



![image-20230402163730621](images/image-20230402163730621.png)





### 语法分析： 分析树和二义性

![image-20230402164752042](images/image-20230402164752042.png)





![image-20230402164908240](images/image-20230402164908240.png)





![image-20230402165740071](images/image-20230402165740071.png)





### 二义性文法

![image-20230402170101814](images/image-20230402170101814.png)



![image-20230402172433741](images/image-20230402172433741.png)



![image-20230402172625677](images/image-20230402172625677.png)



### 语法分析 --自顶向下

![image-20230402173000866](images/image-20230402173000866.png)





![image-20230402173524999](images/image-20230402173524999.png)







![image-20230402175847074](images/image-20230402175847074.png)





#### 算法的讨论



![image-20230402180040136](images/image-20230402180040136.png)



![image-20230402180519014](images/image-20230402180519014.png)



### 语法分析： 递归下降分析

![image-20230403193918679](images/image-20230403193918679.png)







![image-20230403194522116](images/image-20230403194522116.png)



![image-20230403194925233](images/image-20230403194925233.png)



---

### 语法分析： LL（1） 分析算法

![image-20230403201150941](images/image-20230403201150941.png)





![image-20230403201433365](images/image-20230403201433365.png)



 



![image-20230403202046178](images/image-20230403202046178.png)





![image-20230403202231556](images/image-20230403202231556.png)



 

![image-20230405123325464](images/image-20230405123325464.png)





#### FIRST 集

![image-20230405124624338](images/image-20230405124624338.png)



 

![image-20230405125756864](images/image-20230405125756864.png)





![image-20230403211316781](images/image-20230403211316781.png)







![image-20230403211554076](images/image-20230403211554076.png)





![image-20230405133907597](images/image-20230405133907597.png)



![image-20230405134224923](images/image-20230405134224923.png)



#### 一般条件下的LL（1）分析表的构造 

![image-20230405141558573](images/image-20230405141558573.png)





 

![image-20230404093134912](images/image-20230404093134912.png)





![image-20230405142203578](images/image-20230405142203578.png)

 

![image-20230405143216153](images/image-20230405143216153.png)



## 不懂

### 计算FIRST-S集合

![image-20230405143820971](images/image-20230405143820971.png)



![image-20230405145037710](images/image-20230405145037710.png)



 ![image-20230405145323673](images/image-20230405145323673.png)



### LR(0)分析算法

#### ![image-20230405174943994](images/image-20230405174943994.png)

### 自底向上分析算法

![image-20230405175119568](images/image-20230405175119568.png)





![image-20230405175812240](images/image-20230405175812240.png)



#### 点记号



![image-20230405175945986](images/image-20230405175945986.png)







![image-20230405180137351](images/image-20230405180137351.png)





![image-20230405181000569](images/image-20230405181000569.png)





![image-20230405183033295](images/image-20230405183033295.png)





![image-20230405183330425](images/image-20230405183330425.png)





### LR(0)分析算法



![image-20230405184606405](images/image-20230405184606405.png)







## 语法制导翻译

![image-20230405185151926](images/image-20230405185151926.png)



---

# 抽象语法树

![image-20230405195819517](images/image-20230405195819517.png)



![image-20230405200022479](images/image-20230405200022479.png)



![image-20230405200132401](images/image-20230405200132401.png)





![image-20230405202456737](images/image-20230405202456737.png)



![image-20230405211312051](images/image-20230405211312051.png)





https://www.bilibili.com/video/BV16h411X7JY?t=2.8&p=73

































































